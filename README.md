# Coding_Workspace 

자료구조, 알고리즘 등 개인공부한 내용들을 올리는 저장소입니다.

# JAVA 문법

**spring boot 사용전 JAVA에서 필수로 알고 있어야 할 개념 정리**

**자바 기본 문법**

[자바의 변수](https://www.notion.so/JAVA-610da8f3061540b08e10b0bd8b92cf30?pvs=21), [데이터 타입](https://www.notion.so/JAVA-610da8f3061540b08e10b0bd8b92cf30?pvs=21), [연산자](https://www.notion.so/JAVA-610da8f3061540b08e10b0bd8b92cf30?pvs=21), [조건문](https://www.notion.so/JAVA-610da8f3061540b08e10b0bd8b92cf30?pvs=21), 메서드, [클래스](https://www.notion.so/JAVA-610da8f3061540b08e10b0bd8b92cf30?pvs=21) 등과 같은 기본 문법을 이해해야 합니다. 자바 언어의 기본 구문과 문법에 익숙해지는 것이 중요합니다.

**객체 지향 프로그래밍 (OOP)**

자바는 객체 지향 프로그래밍 언어로, 클래스, 객체, 상속, 다형성, 캡슐화 등의 개념을 이해해야 합니다. 객체 지향 프로그래밍은 소프트웨어를 모듈화하고 유지보수하기 쉽게 만들어주는 중요한 개념입니다.

**컬렉션 프레임워크**

자바에서는 다양한 데이터 구조를 제공하는 컬렉션 프레임워크를 활용하여 데이터를 관리할 수 있습니다. ArrayList, LinkedList, HashMap 등과 같은 컬렉션 클래스를 이해하고 활용하는 방법을 배워야 합니다.

**예외 처리**

자바에서는 예외 처리를 통해 프로그램에서 발생할 수 있는 오류나 예외 상황을 다룹니다. try-catch 블록을 사용하여 예외를 처리하고, 예외를 발생시키는 방법과 예외 클래스의 계층 구조를 이해해야 합니다.

**스레드**

자바는 멀티스레드 프로그래밍을 지원하므로 스레드에 대한 이해가 필요합니다. 스레드 생성, 동기화, 상호 작용, 스레드 풀 등 스레드 관련 개념을 배워야 합니다.

**입출력 (I/O)**

파일 및 네트워크와의 상호 작용을 위해 자바의 입출력 기능을 이해해야 합니다. 파일 읽기/쓰기, 네트워크 통신 등을 다룰 수 있어야 합니다.

**제네릭 (Generics)**

자바의 제네릭을 사용하면 타입 안정성을 보장하고 코드 재사용성을 높일 수 있습니다. 제네릭의 개념과 활용 방법을 이해하고 사용할 수 있어야 합니다.

# 자료형과 변수

JAVA에서 데이터를 저장하고 처리할 때 변수와 자료형을 사용한다. 

자료형은 변수가 어떤 종류의 데이터를 저장할 수 있는지를 정의하고 

변수는 실제 데이터를 저장하는 메모리 공간이다.

1. 기본 자료형
- 정수형 : byte, short, int, long
- 실수형 : float, double
- 문자형 : char
- 논리형 : boolean

기본 자료형은 메모리에 값을 직접 저장한다.

```jsx
int age = 25;
double price = 19.99;
char grade = 'A';
boolean isTrue = true;
```

2.  참조 자료형

- 클래스 : 사용자가 정의한 클래스
- 배열 : 동일한 자료형의 여러 값을 저장하는 배열

참조 자료형은 객체를 참조하는 변수이다. 메모리에 객체가 저장되고, 변수는 해당 객체를 참조하는 주소를 저장한다.

```jsx
String name = "John";
Date today = new Date();
int[] numbers = {1, 2, 3, 4, 5};
```

자바에서 변수를 선언할 때 변수의 자료형을 명시해야 한다. 변수를 선언할 때는

```jsx
<자료형> <변수명>;

// 예시
int age;
double price;
String name;
```

변수가 선언된 이후에는 값을 할당하거나 변경할 수 있다.

```jsx
<변수명> = <값>;

// 예시
age = 25;
price = 19.99;
name = "John";
```

변수를 선언하는 동시에 값을 할당할 수도 있다.

```jsx
<자료형> <변수명> = <값>;

// 예시
int age = 25;
double price = 19.99;
String name = "John";
```

# **데이터 타입**

1. 기본 데이터 타입 (Primitive Types):
    - **`byte`**
        
        8비트(1바이트) 정수를 저장하는 타입. 
        
        범위 : -128 ~ 127
        
    - **`short`**:
        
        16비트(2바이트) 정수를 저장하는 타입. 
        
        범위 : -32,768 ~32,767
        
    - **`int`**
        
        32비트(4바이트) 정수를 저장하는 타입. 
        
        범위 : 약 -21억 ~ 21억
        
    - **`long`**
        
        64비트(8바이트) 정수를 저장하는 타입. 
        
        범위 : 매우 큰 값까지 표현할 수 있다.
        
    - **`float`**
        
        32비트(4바이트) 부동소수점 수를 저장하는 타입.
        
        정밀도 : 7자리.
        
    - **`double`**
        
         64비트(8바이트) 부동소수점 수를 저장하는 타입.
        
        정밀도 : 15자리입니다.
        
    - **`char`**
        
        16비트(2바이트) 유니코드 문자를 저장하는 타입.
        
    - **`boolean`**
        
        8비트(1바이트)
        
        **`true`** 또는 **`false`** 값을 저장하는 타입.
        

2.참조 데이터 타입

- 클래스 (Class)
    
    객체를 생성하기 위한 템플릿.
    
     사용자가 직접 클래스를 정의하고 사용할 수 있다.
    
- 배열 (Array)
    
    동일한 데이터 타입의 여러 값을 저장하는 자료구조. 
    
    배열은 참조 타입이지만, 자바에서 특별한 문법으로 기본 데이터 타입의 배열을 사용할 수 있다.
    
- 인터페이스 (Interface)
    
    클래스가 구현해야 할 메서드들의 집합을 정의하는 타입.
    
- 열거형 (Enumeration)
    
    몇 개의 상수로 제한된 타입.
    

# **연산자**

연산자란 프로그램에서 데이터를 처리하여 결과를 산출하는 것을 말한다

연산에 사용되는 표시나 기호를 연산자라고 한다.

연산되는 데이터를 피연산자라고 한다.

### **연산자 우선순위**

| 우선순위 | 중류 | 연산자 |
| --- | --- | --- |
| 1순위 | https://www.notion.so/JAVA-610da8f3061540b08e10b0bd8b92cf30?pvs=21 | ++, - - |
| 2순위 | 산술 연산자 | +, -, * , / , % |
| 3순위 | https://www.notion.so/JAVA-610da8f3061540b08e10b0bd8b92cf30?pvs=21 | >> , << , >>> |
| 4순위 | 비교 연산자 | >, <. >=, <=, ==, ≠ |
| 5순위(~ : 1순위) | https://www.notion.so/JAVA-610da8f3061540b08e10b0bd8b92cf30?pvs=21 | &, |, ^, ~ |
| 6순위(! : 1순위 | https://www.notion.so/JAVA-610da8f3061540b08e10b0bd8b92cf30?pvs=21 | &&, ||, ! |
| 7순위 | 조건 연산자 | ?, : |
| 8순위 | 대입 연산자 | =, *=, /=, %=, +=, -= |

**증감 연산자**

| 증감 연산자 | 설명 |
| --- | --- |
| ++x | 먼저 피연산자의 값을 1 증가시킨 후에 해당 연산을 진행함. |
| x++ | 먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 증가시킴. |
| - -x | 먼저 피연산자의 값을 1 감소시킨 후에 해당 연산을 진행함. |
| x- - | 먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 감소시킴. |

**논리 연산자**

| 논리 연산자 | 설명 |
| --- | --- |
| && | 논리식이 모두 참이면 참을 반환함.(논리AND 연산) |
| || | 논리식 중에서 하나라도 참이면 참을 반환함.(논리 OR 연산) |
| ! | 논리식의 결과가 참이면 거짓을, 거짓이면 참을 반환함.(논리 NOT연산) |

**논리 연산자의 진리표**

| A | B | A&&B | A||B | !A |
| --- | --- | --- | --- | --- |
| T | T | T | T | F |
| T | F | F | T | F |
| F | T | F | T | T |
| F | F | F | F | T |

**비트 연산자**

| 비트 연산자 | 설명 |
| --- | --- |
| & | 비트가 모두 1이면 1을 반환함. (비트 AND 연산) |
| | | 비트 중에서 하나라도 1이면 1을 반환함. (비트 OR 연산) |
| ^ | 비트가 서로 다르면 1을 반환함. (비트 XOR 연산) |
| ~ | 비트를 1이면 0으로, 0이면 1로 반전. (비트 NOT 연산, 1의 보수) |
| << | 명시된 수만큼 비트들을 전부 왼쪽으로 이동시킴. (left shift 연산) |
| >> | 부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동시킴. (right shift 연산) |
| >>> | 지정한 수만큼 비트를 전부 오른쪽으로 이동시키며, 새로운 비트는 전부 0이 됨. |

# 조건문

**제어문**

자바 프로그램이 원하는 결과를 얻기 위해서는 프로그램의 순차적인 흐름을 제어해야만 할 경우가 생긴다.

이때 사용하는 명령문을 제어문이라고 하며, 이러한 제어문에는 조건문, 반복문등이 있다.

이러한 제어문에 속하는 명령문들은 중괄호로 둘러싸여 있으며, 이러한 중괄호 영역을 블록이라고 한다.

조건문

조건문은 조건식의 결과에 따라 별도의 명령을 수행하도록 제어하는 명령문이다.

## **JAVA의 대표적인 조건문의 형태**

**1.if문**

```jsx
if(조건식){
	조건식이 참일때 실행
}
```

**2.if / else 문**

```jsx
if(조건식){
	조건식이 참일때 실행
}else{
	조건식이 거짓일 때 실행
}
```

**3.if / else if / else 문**

```jsx
if(조건식1){
	조건식1이 참일때 실행
}else if(조건식2){
	조건식2이 참일 때 실행
}else{
	조건식1, 조건식2 가 모두 거짓일 때 실행
}
```

*삼항 연산자를 이용한 조건문

```jsx
조건식 ? 반환값 1 : 반환값 2
```

조건식이 참일때 반환값 1 / 거짓일때 반환값 2

**4.switch 문**

```jsx
switch (조건 값) {

    case 값1:

        조건 값이 값1일 때 실행하고자 하는 명령문;

        break;

    case 값2:

        조건 값이 값2일 때 실행하고자 하는 명령문;

        break;

    default:

        조건 값이 어떠한 case 절에도 해당하지 않을 때 실행하고자 하는 명령문;

        break;

}
```

default: 는 반드시 존재해야 하는 것이 아니다. 필요할 때만 선언 할 수 있다.

break 키워드가 없다면, 조건에 해당하는 switch 문의 case 절 이후의 모든 case 절이 전부 실행됨

**반복문**

반복문이란 프로그램 내에서 똑같은 명령을 일정 횟수만큼 반복하여 수행하도록 제어하는 명령문이다.

프로그램이 처리하는 대부분의 코드는 반복적인 형태가 많아 가장 많이 사용되는 제어문 중 하나이다.

## **JAVA의 대표적인 반복문의 형태**

**1.while문**

```jsx
while(조건식){
	조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;
}
```

**2.do / while 문**

```jsx
do{
	조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;
}while(조건식);
```

**3.for 문**

```jsx
for (초기식; 조건식; 증감식) {

    조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;

}
```

*continue 문은 루프 내에서 사용하여 해당 루프의 나머지 부분을 건너뛰고, 바로 다음 조건식의 판단으로 넘어가게 해준다.

*break 문은 루프 내에서 사용하여 해당 반복문을 완전히 종료시킨 뒤, 반복문 바로 다음에 위치한 명령문을 실행.

즉 루프 내에서 조건식의 판단 결과와 상관없이 반복문을 완전히 빠져나가고 싶을 때 사용.

>>>>break을 통해서 반복문 전체를 빠져나가고 싶을 때

```jsx
allLoop :

for (int i = 2; i < 10; i++) {

    for (int j = 2; j < 10; j++) {

        if (i == 5) {

            break allLoop;

        }

        System.out.println(i + " * " + j + " = " + (i * j));

    }

}
```

break 뒤에 반복앞에 설정한 이름을 입력한

[4.**Enhanced for 문**](https://www.notion.so/JAVA-610da8f3061540b08e10b0bd8b92cf30?pvs=21)

# **배열**

**메모리 구조**

모든 자바 프로그램은 JVM(자바 가상 머신)을 통해서 실행된다.

자바 프로그램이 실행되면, JVM은 운영 체제로부터 필요한 메모리를 할당 받는다.

**메소드 영역**

클래스에 대한 정보와 함께 클래스 변수가 저장되는 영역이다..

JVM은 자바 프로그램에서 특정 클래스가 사용되면 해당 클래스의 클래스 파일을 읽어들여, 해당 클래스에 대한 정보를 메소드 영역에 저장한다.

**힙 영역**

자바 프로그램에서 사용되는 모든 인스턴스 변수가 저장되는 영역이다.

JVM은 자바 프로그램에서 new 키워드를 사용하여 인스턴스가 생성되면

인스턴스의 정보를 힙 영역에 저장한다.

힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.

**스택 영역**

자바 프로그램에서 메소드가 호출될 때 메소드의 스택프레이밍 저장되는 영

**1차원 배열**

단일 행으로 구성된 배열.

요소들은 하나의 인덱스를 사용하여 접근한다.

**배열의 선언 및 초기화**

```jsx
<데이터타입>[] <배열이름> = new <데이터타입>[<크기>];

int[] numbers = new int[5]; //길이가 5인 int형 배열의 선언 및 생성
numbers[0] = 1; //인덱스를 이용한 배열의 초기
numbers[1] = 2;
numbers[2] = 3;
numbers[3] = 4;
numbers[4] = 5;
```

배열의 각 요소는 해당 인덱스를 사용하여값을 읽거나 변경할 수 있다.

**배열의 초기화**

```jsx
타입[] 배열이름 = {요소1, 요소2, ...};

타입[] 배열이름 = new 타입[]{요소1, 요소2, ...};

```

**다차원 배열**

2차원 이상의 배열을 의미, 배열 요소로 또 다른 배열을 가지는 배열을 의미한다.

-2차원 배열은 배열 요소로 1차원 배열을 가지는 배열

-3차원 배열은 배열 요소로 2차원 배열을 가지는 배열

**2차원 배열**

```jsx
타입[][] 배열이름;

타입 배열이름[][];

타입[] 배열이름[];
```

int[][] arr = new int[2][4];

| arr[0][0] | arr[0][1] | arr[0][2] | arr[0][3] |
| --- | --- | --- | --- |
| arr[1][0] | arr[1][1] | arr[1][2] | arr[1][3] |

**2차원 배열의 선언과 동시에 초기화하는 방법**

```jsx
int[][] arr = {

    {0, 20, 35},

    {30, 50, 40}

};
```

**가변 배열**

2차원 배열 생성시 길이를 명시하지 않음으로 행마다 다른 길이의 배열 요소로 저장할 수 있다.

```jsx
int[][] arr = new int[3][];

arr[0] = new int[2];

arr[1] = new int[4];

arr[2] = new int[1];
```

**배열 메소드 활용**

**배열 복사**

배열은 한 번 생성후 그 길이를 변경할 수 없다.

더 많은 데이터를 저장하기 위해서는 더 큰 배열을 만들고 이전 배열의 데이터를

복사해서 가져와야 한다.

- System 클래스의 arraycopy() 메소드
- Arrays 클래스의 copyOf() 메소드
- Object 클래스의 clone() 메소드
- for 문과 인덱스를 이용하여 복사

```jsx
int[] arr1 = new int[]{1, 2, 3, 4, 5};

int newLen = 10;

 

// 1. System 클래스의 arraycopy() 메소드

int[] arr2 = new int[newLen];

System.arraycopy(arr1, 0, arr2, 0, arr1.length);

 

// 2. Arrays 클래스의 copyOf() 메소드

int[] arr3 = Arrays.copyOf(arr1, 10);

 

// 3. Object 클래스의 clone() 메소드

int[] arr4 = (int[])arr1.clone();

 

// 4. for 문과 인덱스를 이용한 복사

int[] arr5 = new int[newLen];
```

### **1.System.arraycopy**

System.arraycopy (src, srcPos, dest, destPos, length)

(복사하려고 하는 원본, 원본에서 불러올 위치, 복사할 소스, 복사본의 위치, 원본에서 얼마큼 읽어올지)

src - 원본 배열
srcPos - 원본 배열의 복사 시작 위치
dest - 복사할 배열
destPost - 복사할 배열의 복사 시작 위치
length - 복사할 요소의 개수

int length : 원본에서 복사본으로 읽어서 쓸 데이터 길이. 원본에서 복사본까지 얼마큼 읽어 올지 입력.

```jsx
//32 byte key(원본)
byte[] secretKey = 32 byte byte[]

//16 byte key(첫번째 복사할 대상)
byte[] key = new byte[16];

//16 byte IV(두번째 복사할 대상)
byte[] iv = new byte[16];

//key.length(16 byte) 만큼 원본 데이터를 읽어온 후 key라는 변수에 씁니다.
System.arraycopy(secretKey, 0 ,key, 0, key.length);

//iv.length(16 byte) 만큼 원본 데이터를 읽어온 후 iv라는 변수에 씁니다.
System.arraycopy(secretKey, key.length , iv, 0, iv.length);
```

**Enhanced for 문**

배열과 컬렉션의 모든 요소를 참조하기 위해 추가 된 반복문

```jsx
for (타입 변수이름 : 배열이나컬렉션이름) {

    배열의 길이만큼 반복적으로 실행하고자 하는 명령문;

}

int[] arr = new int[]{1, 2, 3, 4, 5};

for (int e : arr) {

    System.out.print(e + " ");

}
//요소의 값을 변경하는 작업에는 적합하지 않다.
//원본의 배열의 복사본이라고 생각하면 편하다.

for (int e : arr) {

    e += 10;

}//결과 값 1 2 3 4 5
//배열의 값이 변경되지 않
```

### 2.Arrays.copyOf()

는 특정 배열의 원하는 길이만큼 새로운 배열로 복사하는 메소드 함수.

새로운 배열 = Arrays.copyof(원본 배열, 원본 배열에서 복사하고 싶은 요소들의 길이);

```jsx
int[] arr = {1, 2, 3, 4, 5};

int[] arr1 = Arrays.copyOf(arr, 2);
int[] arr2 = Arrays.copyOf(arr, 7);

>>1 2
>>1 2 3 4 5 0 0
```

### **3.clone()**

참고 사이트

[https://velog.io/@roro/Java-Object-클래스-clone](https://velog.io/@roro/Java-Object-%ED%81%B4%EB%9E%98%EC%8A%A4-clone)

## **클래스**

**객체 지향 프로그래밍(OOP)**

OOP에서는 모든 데이터를 object로 취급하고 이 object가 프로그래밍의 중심이 된다.

object란 우리가 실생활에서 인식할 수 있는 사물로 설명할 수 있다.

이러한 객체의 **상태**와 **행동**을 구체화하는 형태의 프로그래밍이 객체 지향 프로그래밍(OOP)라고 한다. 이때 객체를 만들어 내기 위한 설계도와 같은 개념을 **클래스**(class)라고 한다.

---

**클래스**

자바에서 class란 객체를 정의하는 **틀 or 설계도**로 사용된다.

클래스는  객체의 상태를 나타내는 **필드(field)**와 행동을 나타내는 **메소드(method)**로 구성된다.

즉, **필드(field)**란 클래스에 포함된 변수를 의미한다.

**메소드(method)**란 어떠한 특정 작업을 수행하기 위한 명령문의 집합이라고 할 수 있다.

**클래스의 선언**

클래스란 객체 지향 프로그래밍의 추상화라는 개념을 직접 구현한 것이다.

자바에서 클래스를 선언하는 방법은 접근 제어자와 함께 class 키워드를 사용한다

---

**인스턴스(instance)**

자바에서 클래스를 사용하기 위해서는 해당 클래스 타입의 객체(object)를 선언해야 한다.

클래스로부터 객체를 선언하는 과정을 클래스의 인스턴스 화 라고 한다.

그리고 이렇게 선언된 해당 클래스 타입의 객체를 인스턴스(inctance)라고 한다.

자바에서는 하나의 클래스로부터 여러 개의 인스턴스를 생성할 수 있다.

이렇게 생성된 인스턴스는 독립된 메모리 공간에 저장된 자신만의 필드를 가질 수 있다.

하지만 해당 클래스의 모든 메소드(method)는 해당 클래스에서 생성된 모든 인스턴스가 공유하게 된다.

---

//클래스의 예

클래스(class)
휴대폰(phone) : 설계도

필드(field)

phone.modelName = “아이폰”

phone.modelYear = 2020

phone.color = “흰색”

phone.maxBattery = 400

메소드(method)

phone.onoff( )

phone.airplaneMode( )

**인스턴스(instance)**

내 폰(myPhone) : 설계도에 의해 생산된 휴대폰

친구 폰(friendPhone) : 설계도에 의해 생산된 또 다른 휴대폰

휴대폰 인스턴스는 모두 위와 같은 필드와 메소드를 가지게 된다

하지만 각 인스턴스 마다 가지고 있는 프로파티의 값은 전부 다를 것이다.

**클래스의 구성요소**

자바에서 클래스는 멤버(member)로 속성을 표현하는 필드(field)와 기능을 표현하는 메소드(method)를 가진다.

클래스는 생성된 객체의 필드를 초기화해주는 특별한 메소등인 생성자(constructor)을 가진다.

```jsx
class Phone {
	private String modelName;
	//문자열 타입의 private 멤버변수
	private int modelYear;
	//정수형 타입의 private 멤버변수

	Phone(String modelName, int modelYear){//생성자 선언
		this.modelName = modelName;
		//modelName 피라미터 값을 modelName 멤버변수에 할당
		this.modelYear = medelYear;
		//modelYear 피라미터 값을 modelYear 멤버변수에 할당
	}

	public String getModel() {//getModel 메서드 선언
		return this.modelYear + "년식" + this.modelName + " " + this.color
		//modelYear와 modelName을 조합하여 반환
	}
}

```

**`modelName`**과 **`modelYear`**는 private 멤버 변수로 선언되어 클래스 외부에서 직접 접근할 수 없다.

대신 생성자를 통해 값을 초기화 하여 **`getModel`**  메서드를 통해 값을 반환할 수 있다.

생성자 **`Phone(String modelName, int modelYear)`**은 두 개의 파라미터를 받아서 **`modelName`**과 **`modelYear`** 멤버 변수에 값을 할당한다. **`this`** 키워드는 현재 인스턴스를 가리키며, **`this.modelName`**과 **`this.modelYear`**는 인스턴스의 멤버 변수를 참조한다.

**`getModel`** 메서드는 **`modelYear`**와 **`modelName`**을 조합하여 문자열로 반환하고 반환되는 문자열은 **`modelYear + "년식 " + modelName`**의 형태다.

이제 **`Phone`** 클래스를 사용하여 객체를 생성하고 **`getModel`** 메서드를 호출하여 값을 확인할 수 있다. 예를 들어:

```jsx
public class Main {
	public static void main(String[] args) {
		Phone myPhone = new Phone("Galaxy S21", 2021);
		//클래스이름 객체참조변수이름 = new 클래스이름();
		System.out.println(myPhone.getModel()); // "2021년식 Galaxy S21" 출력
	}
}
```

위의 예시 코드에서 **`Phone`** 클래스의 인스턴스 **`myPhone`**을 생성하고 생성자에 "Galaxy S21"과 2021을 전달하여 객체를 초기화 한다. 그리고 **`getModel`** 메서드를 호출하여 모델명과 출시년도를 문자열로 출력한다. 출력 결과는 "2021년식 Galaxy S21"이 된다.

**필드(field)**

클래스의 필드란 클래스에 포함된 변수를 의미한다.

클래스 내에서 필드는 선언된 위치에 따라 다음과 같이 구분된다.

1. 클래스 변수
2. 인스턴스 변수
3. 지역 변수

## **메소드(method)**

자바에서 클래스는 멤버(meber)로 속성을 표현하는 필드(field)와 기능을 표현하는 메소드(method)를 가진다.

그중에서 메소드(method)란 어떠한 특정 작업을 수행하기 위한 명령문의 집합이라고 할 수 있다.

자바에서 메소드를 정의하는 방법은

```jsx
접근제어자 반환타입 메소드이름(매개변수목록) {
//선언부
}
```

1. 접근 제어자 : 해당 메소드에 접근할 수 있는 범위를 명시.
2. 반환 타입(return type) : 메소드가 모든 작업을 마치고 반환하는 데이터의 타입을 명시.
3. 메소드 이름 : 메소드를 호출하기 위한 이름을 명시.
4. 매개변수 목록(parameters) : 메소드 호출 시에 전달되는 인수의 값을 저장할 변수들을 명시.
5. 구현부 : 메소드의 고유 기능을 수행하는 명령문의 집합.

*하나의 클래스에 같은 이름의 메소드를 둘 이상 정의할 수 없다.

>>> 하지만 메소드 오버로딩(overloading)을 이용하면, 같은 이름의 메소드를 중복하여 정의할 수 있다.

메소드 오버로딩이란 매개변수의 개수나 타입을 다르게 하여 같은 이름의 또 다른 메소드를 작성하는 것이다.

**메소드**

클래스에서 메소드란 어떠한 특정 작업을 수행하기 위한 명령문의 집합이다.

즉, 메소드를 사용하여 중복되는 코드의 반복적인 프로그래밍을 피할 수 있게 된다.

또한, 모듈화로 인해 전체적인 코드의 가독성이 좋아지고 손쉽게 유지보수를 할 수 있다.

**메소드 정의**

```jsx
접근제어자 반환타입 메소드이름(매개변수목록) { // 선언부

    // 구현부

}
```

1. 접근 제어자 : 해당 메소드에 접근할 수 있는 범위를 명시
2. 반환 타입(return type) : 메소드가 모든 작업을 마치고 반환하는 데이터의 타입을 명시
3. 메소드 이름 : 메소드를 호출하기 위한 이름을 명시
4. 매개변수 목록(parameters) : 메소드 호출 시에 전달되는 인수의 값을 저장할 변수들을 명시
5. 구현부 : 메소드의 고유 기능을 수행하는 명령문의 집합

**메소드 호출**

멤버 참조 연산자(.)를 사용하여 호출

```jsx
public class Main {
	public static void main(String[] args) {
		Phone myPhone = new Phone(); //객체를 생성
		myPhone.getModel("Galaxy S21", 2021);
		//myPhone 인스턴스의 getModel() 메소드를 호출
	}
}
```

**생성자**

인스턴스 변수의 초기화

클래스를 가지고 객체를 생성하면, 해당 캑체는 메모리에 즉시 생성된다. 하지만 생성된 객체는 모든 인스턴스 변수가 아직 초기화되지 않은 상태다.

따라서 자바에서는 객체의 생성과 동시에 인스턴스 변수를 원하는 값으로 초기화 할 수 있는 생성자라는 메소드를 제공한다

자바에서 생성자의 이름은 해당 클래스의 이름과 같아야 한다.

Phone 클래스의 생성자는 Phone( ) 이 된다.

1. 생성자는 반환값이 없지만, 반환 타입을 void형으로 선언하지 않는다.
2. 생성자는 초기화를 위한 데이터를 인수로 전달받을 수 있다.
3. 객체를 초기화하는 방법이 여러 개 존재할 경우에는 하나의 클래스가 여러 개의 생성자를 가질 수 있다.
    
    즉, 생성자도 하나의 메소드이므로, 메소드 오버로딩이 가능하다는 의미.
    

```jsx
Phone(String modelName) {}

Phone(String modelName, int modelYear) {}

Phone(String modelName, int modelYear, String color) {}

Phone(String modelName, int modelYear, String color, int maxSpeeds) {
		this.modelName = modelName;

    this.modelYear = modelYear;

    this.color = color;

    this.maxSpeed = maxSpeed;

    this.currentSpeed = 0;
}

```

### 생성자의 호출

자바에서는 new 키워드를 사용하여 객체를 생성할 때 자동으로 생성자가 호출된다.

```jsx
class Phone{

    private String modelName;

    private int modelYear;

    private String color;

    private int maxSpeed;

    private int currentSpeed;

 

    Car(String modelName, int modelYear, String color, int maxSpeed) {

        this.modelName = modelName;

        this.modelYear = modelYear;

        this.color = color;

        this.maxSpeed = maxSpeed;

        this.currentSpeed = 0;

    }

 

    public String getModel() {

        return this.modelYear + "년식 " + this.modelName + " " + this.color;

    }

}

 

public class Method02 {

    public static void main(String[] args) {
		Phone myPhone = new Phone("Galaxy S21", 2021, "흰색", 200);
		// 생성자의 호출
		System.out.println(myPhone.getModel()); //생성자에 의해 초기화되었는지를 확인함.
	}

}
```

## **this 참조 변수**

현재 객체의 참조를 가르키는 키워드

class 내부에서 인스턴스 변수, 인스턴스 메서드, 또는 다른 생성자를 참조할 때 사용된다

this는 해당 클래스의 현재 인스턴스를 가르키며 인스턴스의 멤버에 접근할 수 있도록 도와준다

```jsx
class Person {
    private String name;

    public Person(String name) {
        this.name = name; // name은 생성자의 파라미터, this.name은 인스턴스 변수
    }

    public void setName(String name) {
        this.name = name; // name은 메서드의 파라미터, this.name은 인스턴스 변수
    }
}
```

**`this.name`**은 인스턴스 변수 **`name`**을 가리킨다.  **`this`**를 사용하여 현재 객체의 인스턴스 변수를 명시적으로 참조할 수 있다.

## this( )

this( )는 같은 클래스의 다른 생성자를 호출하는 특별한 문법이다

생성자 내에서 다른 생성자를 호출할 때 사용되며 객체 초기화를 단순화하고 코드의 중복을 피할 수 있다.

this( ) 호출은 생성자 내에서 첫 번째 문장으로 작성되어야 한다.

```jsx
class Rectangle {
    private int width;
    private int height;

    public Rectangle() {
        this(0, 0); // Rectangle(int width, int height) 생성자 호출
    }

    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
    }
}
```

위 예시에서 생성자는 위의 예시에서 **`Rectangle()`** 생성자는 **`this(0, 0)`**을 통해 **`Rectangle(int width, int height)`** 생성자를 호출한다. 이렇게 함으로써 매개변수를 가지고 있는 다른 생성자를 호출하면서 객체를 초기화할 수 있다. 이를 통해 초기화 코드의 중복을 피하고, 생성자 간의 로직을 재사용할 수 있다.

이처럼 **`this`**와 **`this()`**는 자바에서 객체의 참조와 생성자 호출에 사용되는 특별한 키워드다. **`this`**를 사용하여 인스턴스 변수와 메서드를 참조하고, **`this()`**를 사용하여 같은 클래스의 다른 생성자를 호출할 수 있다.

## 메소드 오버로딩

JAVA에서 메소드 오버로딩은 동일한 메소드 이름을 가지면서 매개변수의 개수, 순서, 타입이 다른 여러 개의 메소드를 정의하는 것을 말한다.

메소드 오버로딩은 코드의 가독성을 높이고 유지 보수성을 개선하기 위해 사용된다.

**메소드 오버로딩의 규칙**

1. 메소드 이름이 동일해야 한다.
2. 메소드 시그니처가 달라야 한다. 메소드 시그니처는 매개변수의 개수, 순서, 타입으로 결정된다.
    
    반환 타입은 메소드 시그니처에 포함되지 않는다.
    

  3. 메소드 시그니처는 메소드를 구별하기 위해 사용된다.

**메소드 오버로딩의 장점**

1. 가독성 향상 : 메소드의 이름이 동일하므로 비슷한 동작을 하는 메소드들을 논리적으로 그룹화하여 코드를 읽고 이해하기 쉽게 만든다.
2. 유연성 : 당양한 매개변수 조합에 따라 메소드를 호출할 수 있다. 메소드 시그니처에 막는 가장 적합한 메소드가 자동으로 선택된다.
3. 중복 코드 제거 : 비슷한 동작을 하는 메소드들을 하나로 통합하여 코드의 중복을 제거할 수 있다.
4. 코드의 일관성 : 같은 목적을 가지고 있는 메소드들을 동일한 이름으로 정의하므로, 메소드의 목적과 역할이 명확해지고 일관성을 유지할 수 있다.

**메소드 오버로딩 예시**

```jsx
class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public double add(double a, double b) {
        return a + b;
    }

    public int add(int a, int b, int c) {
        return a + b + c;
    }
}
```

위의 예시에서 **`Calculator`** 클래스는 **`add`**라는 메소드를 세 번 오버로딩하고 있다.

 첫 번째 **`add`** 메소드는 두 개의 정수를 더하여 정수를 반환한다.

 두 번째 **`add`** 메소드는 두 개의 실수를 더하여 실수를 반환한다.

 세 번째 **`add`** 메소드는 세 개의 정수를 더하여 정수를 반환한다.

이렇게 메소드 오버로딩을 사용하면, 동일한 기능을 가진 메소드들을 하나의 이름으로 그룹화하여 사용할 수 있다.

호출 시에는 인자의 타입과 개수에 따라 적절한 메소드가 자동으로 선택되어 실행된다.

메소드 오버로딩은 자바에서 유용한 기능 중 하나로, 다양한 매개변수 조합에 대해 일관된 인터페이스를 제공하면서 코드의 가독성과 재사용성을 향상시킨다.

## **패키지**

**패키지**

자바에서 패키지란 클래스와 인터페이스의 집합을 의미한다.

이렇게 서로 관련이 있는 클래스나 인터페이스를 함께 묶음으로써 파일을 효율적으로 관리 할 수 있다.

JAVA에서 패키지는 물리적으로 하나의 디렉터리를 말한다.

**ipmport 문**

패키지에 속한 클래스를 다른 파일에서 사용하기 위해서는 클래스 이름 앞에 패키지의 경로까지 포함한 풀 네임을 명시해 사용해야 한다.

하지만 클래스를 사용할 때마다 매번 긴 이름을 사용하는 것은 비효율 적이므로 자바에서는 import키워드를 별도로 제공한다.

import문은 자바 컴파일러에 코드에서 사용할 클래스의 패키지에 대한 정보를 미리 제종하는 역할을 한다.  따라서  import문을 사용하면 다른 패키지에 속한 클래스를 패키지이름을 제외한 클래스 이름만으로 사용 할 수 있다.

```jsx
java.lang.String
//위의 예제에서 자바의 String 클래스는 java.lang 패키지에 속한 클래스라는 것을 알 수 있다.

package 패키지이름;
//위와 같은 명령문을 클래스나 인터페이스의 소스 파일에 추가한다.
//이때 패키지 이름에는 패키지의 경로까지 포함한 풀 네임을 명시해야 한다.

import 패키지이름.클래스이름; //1

import 패키지이름.*; //2
//패키지 이름에는 페키지의 경로까지 포함한 풀 네임을 명시해야 한다.
// 1번의 방법은 해당 패키지의 특정 클래스만을 사용하고자 할 때 사용한다.
// 2번의 방법은 해당 패키지의 모든 클래스를 클래스 이름만으로 사용하고 싶을때 사용한다.

import java.awt.*;

import java.util.*;
//import문을 사용할때 (*)을 사용하는 것이 해당 패키지에 포함된 다른 모든 하위 패키지의 클래스를
//포함하는 것은 아니다.

//import java.*; <<< 사용 x
//또한, 자바에서는 가장 많이 사용하는 java.lang 패키지에 대해서는 
//import 문을 사용하지 않아도 클래스 이름만으로 사용할 수 있다.
```

## **접근 제어자**

제어자(modifier)

**문자열**

**제어문**

**배열**

**메소드**

**클래스**

**추상클래스와 인터페이스**

**제네릭스**

**익명클래스, 람다와 스트림**

**예외처리**

**쓰레드**

# Coding_Workspace 자료구조, 알고리즘 등 개인공부한 내용들을 올리는 저장소입니다.**입출력과 파일**
