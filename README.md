# Coding_Workspace
자료구조, 알고리즘 등 개인공부한 내용들을 올리는 저장소입니다.

# JAVA 문법

**spring boot 사용전 JAVA에서 필수로 알고 있어야 할 개념 정리**

**자바 기본 문법**

[자바의 변수](https://www.notion.so/JAVA-610da8f3061540b08e10b0bd8b92cf30?pvs=21), [데이터 타입](https://www.notion.so/JAVA-610da8f3061540b08e10b0bd8b92cf30?pvs=21), [연산자](https://www.notion.so/JAVA-610da8f3061540b08e10b0bd8b92cf30?pvs=21), [조건문](https://www.notion.so/JAVA-610da8f3061540b08e10b0bd8b92cf30?pvs=21), 메서드, 클래스 등과 같은 기본 문법을 이해해야 합니다. 자바 언어의 기본 구문과 문법에 익숙해지는 것이 중요합니다.

**객체 지향 프로그래밍 (OOP)**

자바는 객체 지향 프로그래밍 언어로, 클래스, 객체, 상속, 다형성, 캡슐화 등의 개념을 이해해야 합니다. 객체 지향 프로그래밍은 소프트웨어를 모듈화하고 유지보수하기 쉽게 만들어주는 중요한 개념입니다.

**컬렉션 프레임워크**

자바에서는 다양한 데이터 구조를 제공하는 컬렉션 프레임워크를 활용하여 데이터를 관리할 수 있습니다. ArrayList, LinkedList, HashMap 등과 같은 컬렉션 클래스를 이해하고 활용하는 방법을 배워야 합니다.

**예외 처리**

자바에서는 예외 처리를 통해 프로그램에서 발생할 수 있는 오류나 예외 상황을 다룹니다. try-catch 블록을 사용하여 예외를 처리하고, 예외를 발생시키는 방법과 예외 클래스의 계층 구조를 이해해야 합니다.

**스레드**

자바는 멀티스레드 프로그래밍을 지원하므로 스레드에 대한 이해가 필요합니다. 스레드 생성, 동기화, 상호 작용, 스레드 풀 등 스레드 관련 개념을 배워야 합니다.

**입출력 (I/O)**

파일 및 네트워크와의 상호 작용을 위해 자바의 입출력 기능을 이해해야 합니다. 파일 읽기/쓰기, 네트워크 통신 등을 다룰 수 있어야 합니다.

**제네릭 (Generics)**

자바의 제네릭을 사용하면 타입 안정성을 보장하고 코드 재사용성을 높일 수 있습니다. 제네릭의 개념과 활용 방법을 이해하고 사용할 수 있어야 합니다.

# 자료형과 변수

JAVA에서 데이터를 저장하고 처리할 때 변수와 자료형을 사용한다. 

자료형은 변수가 어떤 종류의 데이터를 저장할 수 있는지를 정의하고 

변수는 실제 데이터를 저장하는 메모리 공간이다.

1. 기본 자료형
- 정수형 : byte, short, int, long
- 실수형 : float, double
- 문자형 : char
- 논리형 : boolean

기본 자료형은 메모리에 값을 직접 저장한다.

```jsx
int age = 25;
double price = 19.99;
char grade = 'A';
boolean isTrue = true;
```

2.  참조 자료형

- 클래스 : 사용자가 정의한 클래스
- 배열 : 동일한 자료형의 여러 값을 저장하는 배열

참조 자료형은 객체를 참조하는 변수이다. 메모리에 객체가 저장되고, 변수는 해당 객체를 참조하는 주소를 저장한다.

```jsx
String name = "John";
Date today = new Date();
int[] numbers = {1, 2, 3, 4, 5};
```

자바에서 변수를 선언할 때 변수의 자료형을 명시해야 한다. 변수를 선언할 때는

```jsx
<자료형> <변수명>;

// 예시
int age;
double price;
String name;
```

변수가 선언된 이후에는 값을 할당하거나 변경할 수 있다.

```jsx
<변수명> = <값>;

// 예시
age = 25;
price = 19.99;
name = "John";
```

변수를 선언하는 동시에 값을 할당할 수도 있다.

```jsx
<자료형> <변수명> = <값>;

// 예시
int age = 25;
double price = 19.99;
String name = "John";
```

# **데이터 타입**

1. 기본 데이터 타입 (Primitive Types):
    - **`byte`**
        
        8비트(1바이트) 정수를 저장하는 타입. 
        
        범위 : -128 ~ 127
        
    - **`short`**:
        
        16비트(2바이트) 정수를 저장하는 타입. 
        
        범위 : -32,768 ~32,767
        
    - **`int`**
        
        32비트(4바이트) 정수를 저장하는 타입. 
        
        범위 : 약 -21억 ~ 21억
        
    - **`long`**
        
        64비트(8바이트) 정수를 저장하는 타입. 
        
        범위 : 매우 큰 값까지 표현할 수 있다.
        
    - **`float`**
        
        32비트(4바이트) 부동소수점 수를 저장하는 타입.
        
        정밀도 : 7자리.
        
    - **`double`**
        
         64비트(8바이트) 부동소수점 수를 저장하는 타입.
        
        정밀도 : 15자리입니다.
        
    - **`char`**
        
        16비트(2바이트) 유니코드 문자를 저장하는 타입.
        
    - **`boolean`**
        
        8비트(1바이트)
        
        **`true`** 또는 **`false`** 값을 저장하는 타입.
        

2.참조 데이터 타입

- 클래스 (Class)
    
    객체를 생성하기 위한 템플릿.
    
     사용자가 직접 클래스를 정의하고 사용할 수 있다.
    
- 배열 (Array)
    
    동일한 데이터 타입의 여러 값을 저장하는 자료구조. 
    
    배열은 참조 타입이지만, 자바에서 특별한 문법으로 기본 데이터 타입의 배열을 사용할 수 있다.
    
- 인터페이스 (Interface)
    
    클래스가 구현해야 할 메서드들의 집합을 정의하는 타입.
    
- 열거형 (Enumeration)
    
    몇 개의 상수로 제한된 타입.
    

# **연산자**

연산자란 프로그램에서 데이터를 처리하여 결과를 산출하는 것을 말한다

연산에 사용되는 표시나 기호를 연산자라고 한다.

연산되는 데이터를 피연산자라고 한다.

### **연산자 우선순위**

| 우선순위 | 중류 | 연산자 |
| --- | --- | --- |
| 1순위 | https://www.notion.so/JAVA-610da8f3061540b08e10b0bd8b92cf30?pvs=21 | ++, - - |
| 2순위 | 산술 연산자 | +, -, * , / , % |
| 3순위 | https://www.notion.so/JAVA-610da8f3061540b08e10b0bd8b92cf30?pvs=21 | >> , << , >>> |
| 4순위 | 비교 연산자 | >, <. >=, <=, ==, ≠ |
| 5순위(~ : 1순위) | https://www.notion.so/JAVA-610da8f3061540b08e10b0bd8b92cf30?pvs=21 | &, |, ^, ~ |
| 6순위(! : 1순위 | https://www.notion.so/JAVA-610da8f3061540b08e10b0bd8b92cf30?pvs=21 | &&, ||, ! |
| 7순위 | 조건 연산자 | ?, : |
| 8순위 | 대입 연산자 | =, *=, /=, %=, +=, -= |

**증감 연산자**

| 증감 연산자 | 설명 |
| --- | --- |
| ++x | 먼저 피연산자의 값을 1 증가시킨 후에 해당 연산을 진행함. |
| x++ | 먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 증가시킴. |
| - -x | 먼저 피연산자의 값을 1 감소시킨 후에 해당 연산을 진행함. |
| x- - | 먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 감소시킴. |

**논리 연산자**

| 논리 연산자 | 설명 |
| --- | --- |
| && | 논리식이 모두 참이면 참을 반환함.(논리AND 연산) |
| || | 논리식 중에서 하나라도 참이면 참을 반환함.(논리 OR 연산) |
| ! | 논리식의 결과가 참이면 거짓을, 거짓이면 참을 반환함.(논리 NOT연산) |

**논리 연산자의 진리표**

| A | B | A&&B | A||B | !A |
| --- | --- | --- | --- | --- |
| T | T | T | T | F |
| T | F | F | T | F |
| F | T | F | T | T |
| F | F | F | F | T |

**비트 연산자**

| 비트 연산자 | 설명 |
| --- | --- |
| & | 비트가 모두 1이면 1을 반환함. (비트 AND 연산) |
| | | 비트 중에서 하나라도 1이면 1을 반환함. (비트 OR 연산) |
| ^ | 비트가 서로 다르면 1을 반환함. (비트 XOR 연산) |
| ~ | 비트를 1이면 0으로, 0이면 1로 반전. (비트 NOT 연산, 1의 보수) |
| << | 명시된 수만큼 비트들을 전부 왼쪽으로 이동시킴. (left shift 연산) |
| >> | 부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동시킴. (right shift 연산) |
| >>> | 지정한 수만큼 비트를 전부 오른쪽으로 이동시키며, 새로운 비트는 전부 0이 됨. |

# 조건문

**제어문**

자바 프로그램이 원하는 결과를 얻기 위해서는 프로그램의 순차적인 흐름을 제어해야만 할 경우가 생긴다.

이때 사용하는 명령문을 제어문이라고 하며, 이러한 제어문에는 조건문, 반복문등이 있다.

이러한 제어문에 속하는 명령문들은 중괄호로 둘러싸여 있으며, 이러한 중괄호 영역을 블록이라고 한다.

조건문

조건문은 조건식의 결과에 따라 별도의 명령을 수행하도록 제어하는 명령문이다.

## **JAVA의 대표적인 조건문의 형태**

**1.if문**

```jsx
if(조건식){
	조건식이 참일때 실행
}
```

**2.if / else 문**

```jsx
if(조건식){
	조건식이 참일때 실행
}else{
	조건식이 거짓일 때 실행
}
```

**3.if / else if / else 문**

```jsx
if(조건식1){
	조건식1이 참일때 실행
}else if(조건식2){
	조건식2이 참일 때 실행
}else{
	조건식1, 조건식2 가 모두 거짓일 때 실행
}
```

*삼항 연산자를 이용한 조건문

```jsx
조건식 ? 반환값 1 : 반환값 2
```

조건식이 참일때 반환값 1 / 거짓일때 반환값 2

**4.switch 문**

```jsx
switch (조건 값) {

    case 값1:

        조건 값이 값1일 때 실행하고자 하는 명령문;

        break;

    case 값2:

        조건 값이 값2일 때 실행하고자 하는 명령문;

        break;

    default:

        조건 값이 어떠한 case 절에도 해당하지 않을 때 실행하고자 하는 명령문;

        break;

}
```

default: 는 반드시 존재해야 하는 것이 아니다. 필요할 때만 선언 할 수 있다.

break 키워드가 없다면, 조건에 해당하는 switch 문의 case 절 이후의 모든 case 절이 전부 실행됨

**반복문**

반복문이란 프로그램 내에서 똑같은 명령을 일정 횟수만큼 반복하여 수행하도록 제어하는 명령문이다.

프로그램이 처리하는 대부분의 코드는 반복적인 형태가 많아 가장 많이 사용되는 제어문 중 하나이다.

## **JAVA의 대표적인 반복문의 형태**

**1.while문**

```jsx
while(조건식){
	조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;
}
```

**2.do / while 문**

```jsx
do{
	조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;
}while(조건식);
```

**3.for 문**

```jsx
for (초기식; 조건식; 증감식) {

    조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;

}
```

*continue 문은 루프 내에서 사용하여 해당 루프의 나머지 부분을 건너뛰고, 바로 다음 조건식의 판단으로 넘어가게 해준다.

*break 문은 루프 내에서 사용하여 해당 반복문을 완전히 종료시킨 뒤, 반복문 바로 다음에 위치한 명령문을 실행.

즉 루프 내에서 조건식의 판단 결과와 상관없이 반복문을 완전히 빠져나가고 싶을 때 사용.

>>>>break을 통해서 반복문 전체를 빠져나가고 싶을 때

```jsx
allLoop :

for (int i = 2; i < 10; i++) {

    for (int j = 2; j < 10; j++) {

        if (i == 5) {

            break allLoop;

        }

        System.out.println(i + " * " + j + " = " + (i * j));

    }

}
```

break 뒤에 반복앞에 설정한 이름을 입력한

[4.**Enhanced for 문**](https://www.notion.so/JAVA-610da8f3061540b08e10b0bd8b92cf30?pvs=21)

# **배열**

**메모리 구조**

모든 자바 프로그램은 JVM(자바 가상 머신)을 통해서 실행된다.

자바 프로그램이 실행되면, JVM은 운영 체제로부터 필요한 메모리를 할당 받는다.

**메소드 영역**

클래스에 대한 정보와 함께 클래스 변수가 저장되는 영역이다..

JVM은 자바 프로그램에서 특정 클래스가 사용되면 해당 클래스의 클래스 파일을 읽어들여, 해당 클래스에 대한 정보를 메소드 영역에 저장한다.

**힙 영역**

자바 프로그램에서 사용되는 모든 인스턴스 변수가 저장되는 영역이다.

JVM은 자바 프로그램에서 new 키워드를 사용하여 인스턴스가 생성되면

인스턴스의 정보를 힙 영역에 저장한다.

힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.

**스택 영역**

자바 프로그램에서 메소드가 호출될 때 메소드의 스택프레이밍 저장되는 영

**1차원 배열**

단일 행으로 구성된 배열.

요소들은 하나의 인덱스를 사용하여 접근한다.

**배열의 선언 및 초기화**

```jsx
<데이터타입>[] <배열이름> = new <데이터타입>[<크기>];

int[] numbers = new int[5]; //길이가 5인 int형 배열의 선언 및 생성
numbers[0] = 1; //인덱스를 이용한 배열의 초기
numbers[1] = 2;
numbers[2] = 3;
numbers[3] = 4;
numbers[4] = 5;
```

배열의 각 요소는 해당 인덱스를 사용하여값을 읽거나 변경할 수 있다.

**배열의 초기화**

```jsx
타입[] 배열이름 = {요소1, 요소2, ...};

타입[] 배열이름 = new 타입[]{요소1, 요소2, ...};

```

**다차원 배열**

2차원 이상의 배열을 의미, 배열 요소로 또 다른 배열을 가지는 배열을 의미한다.

-2차원 배열은 배열 요소로 1차원 배열을 가지는 배열

-3차원 배열은 배열 요소로 2차원 배열을 가지는 배열

**2차원 배열**

```jsx
타입[][] 배열이름;

타입 배열이름[][];

타입[] 배열이름[];
```

int[][] arr = new int[2][4];

| arr[0][0] | arr[0][1] | arr[0][2] | arr[0][3] |
| --- | --- | --- | --- |
| arr[1][0] | arr[1][1] | arr[1][2] | arr[1][3] |

**2차원 배열의 선언과 동시에 초기화하는 방법**

```jsx
int[][] arr = {

    {0, 20, 35},

    {30, 50, 40}

};
```

**가변 배열**

2차원 배열 생성시 길이를 명시하지 않음으로 행마다 다른 길이의 배열 요소로 저장할 수 있다.

```jsx
int[][] arr = new int[3][];

arr[0] = new int[2];

arr[1] = new int[4];

arr[2] = new int[1];
```

**배열 메소드 활용**

**배열 복사**

배열은 한 번 생성후 그 길이를 변경할 수 없다.

더 많은 데이터를 저장하기 위해서는 더 큰 배열을 만들고 이전 배열의 데이터를

복사해서 가져와야 한다.

- System 클래스의 arraycopy() 메소드
- Arrays 클래스의 copyOf() 메소드
- Object 클래스의 clone() 메소드
- for 문과 인덱스를 이용하여 복사

```jsx
int[] arr1 = new int[]{1, 2, 3, 4, 5};

int newLen = 10;

 

// 1. System 클래스의 arraycopy() 메소드

int[] arr2 = new int[newLen];

System.arraycopy(arr1, 0, arr2, 0, arr1.length);

 

// 2. Arrays 클래스의 copyOf() 메소드

int[] arr3 = Arrays.copyOf(arr1, 10);

 

// 3. Object 클래스의 clone() 메소드

int[] arr4 = (int[])arr1.clone();

 

// 4. for 문과 인덱스를 이용한 복사

int[] arr5 = new int[newLen];
```

### **1.System.arraycopy**

System.arraycopy (src, srcPos, dest, destPos, length)

(복사하려고 하는 원본, 원본에서 불러올 위치, 복사할 소스, 복사본의 위치, 원본에서 얼마큼 읽어올지)

src - 원본 배열
srcPos - 원본 배열의 복사 시작 위치
dest - 복사할 배열
destPost - 복사할 배열의 복사 시작 위치
length - 복사할 요소의 개수

int length : 원본에서 복사본으로 읽어서 쓸 데이터 길이. 원본에서 복사본까지 얼마큼 읽어 올지 입력.

```jsx
//32 byte key(원본)
byte[] secretKey = 32 byte byte[]

//16 byte key(첫번째 복사할 대상)
byte[] key = new byte[16];

//16 byte IV(두번째 복사할 대상)
byte[] iv = new byte[16];

//key.length(16 byte) 만큼 원본 데이터를 읽어온 후 key라는 변수에 씁니다.
System.arraycopy(secretKey, 0 ,key, 0, key.length);

//iv.length(16 byte) 만큼 원본 데이터를 읽어온 후 iv라는 변수에 씁니다.
System.arraycopy(secretKey, key.length , iv, 0, iv.length);
```

**Enhanced for 문**

배열과 컬렉션의 모든 요소를 참조하기 위해 추가 된 반복문

```jsx
for (타입 변수이름 : 배열이나컬렉션이름) {

    배열의 길이만큼 반복적으로 실행하고자 하는 명령문;

}

int[] arr = new int[]{1, 2, 3, 4, 5};

for (int e : arr) {

    System.out.print(e + " ");

}
//요소의 값을 변경하는 작업에는 적합하지 않다.
//원본의 배열의 복사본이라고 생각하면 편하다.

for (int e : arr) {

    e += 10;

}//결과 값 1 2 3 4 5
//배열의 값이 변경되지 않
```

### 2.Arrays.copyOf()

는 특정 배열의 원하는 길이만큼 새로운 배열로 복사하는 메소드 함수.

새로운 배열 = Arrays.copyof(원본 배열, 원본 배열에서 복사하고 싶은 요소들의 길이);

```jsx
int[] arr = {1, 2, 3, 4, 5};

int[] arr1 = Arrays.copyOf(arr, 2);
int[] arr2 = Arrays.copyOf(arr, 7);

>>1 2
>>1 2 3 4 5 0 0
```

### **3.clone()**

참고 사이트

[https://velog.io/@roro/Java-Object-클래스-clone](https://velog.io/@roro/Java-Object-%ED%81%B4%EB%9E%98%EC%8A%A4-clone)

## **클래스**

**객체 지향 프로그래밍(OOP)**

OOP에서는 모든 데이터를 object로 취급하고 이 object가 프로그래밍의 중심이 된다.

object란 우리가 실생활에서 인식할 수 있는 사물로 설명할 수 있다.

이러한 객체의 **상태**와 **행동**을 구체화하는 형태의 프로그래밍이 객체 지향 프로그래밍(OOP)라고 한다. 이때 객체를 만들어 내기 위한 설계도와 같은 개념을 **클래스**(class)라고 한다.

---

**클래스**

자바에서 class란 객체를 정의하는 **틀 or 설계도**로 사용된다.

클래스는  객체의 상태를 나타내는 **필드(field)**와 행동을 나타내는 **메소드(method)**로 구성된다.

즉, **필드(field)**란 클래스에 포함된 변수를 의미한다.

**메소드(method)**란 어떠한 특정 작업을 수행하기 위한 명령문의 집합이라고 할 수 있다.

---

인스턴스(instance)

자바에서 클래스를 사용하기 위해서는 해당 클래스 타입의 객체(object)를 선언해야 한다.

클래스로부터 객체를 선언하는 과정을 클래스의 인스턴스 화 라고 한다.

그리고 이렇게 선언된 해당 클래스 타입의 객체를 인스턴스(inctance)라고 한다.

자바에서는 하나의 클래스로부터 여러 개의 인스턴스를 생성할 수 있다.

이렇게 생성된 인스턴스는 독립된 메모리 공간에 저장된 자신만의 필드를 가질 수 있다.

하지만 해당 클래스의 모든 메소드(method)는 해당 클래스에서 생성된 모든 인스턴스가 공유하게 된다.

---

//클래스의 예

클래스(class)
휴대폰(phone) : 설계도

필드(field)

phone.modelName = “아이폰”

phone.modelYear = 2020

phone.color = “흰색”

phone.maxBattery = 400

메소드(method)

phone.onoff( )

phone.airplaneMode( )

인스턴스(instance)

내 폰(myPhone) : 설계도에 의해 생산된 휴대폰

친구 폰(friendPhone) : 설계도에 의해 생산된 또 다른 휴대폰

휴대폰 인스턴스는 모두 위와 같은 필드와 메소드를 가지게 된다

하지만 각 인스턴스 마다 가지고 있는 프로파티의 값은 전부 다를 것이다.

메소드(method)

자바에서 클래스는 멤버(meber)로 속성을 표현하는 필드(field)와 기능을 표현하는 메소드(method)를 가진다.

그중에서 메소드(method)란 어떠한 특정 작업을 수행하기 위한 명령문의 집합이라고 할 수 있다.

자바에서 메소드를 덩의하는 방법은

```jsx
접근제어자 반환타입 메소드이름(매개변수목록) {
//선언부
}
```

1. 접근 제어자 : 해당 메소드에 접근할 수 있는 범위를 명시.
2. 반환 타입(return type) : 메소드가 모든 작업을 마치고 반환하는 데이터의 타입을 명시.
3. 메소드 이름 : 메소드를 호출하기 위한 이름을 명시.
4. 매개변수 목록(parameters) : 메소드 호출 시에 전달되는 인수의 값을 저장할 변수들을 명시.
5. 구현부 : 메소드의 고유 기능을 수행하는 명령문의 집합.

*하나의 클래스에 같은 일므의 메소드를 둘 이상 정의할 수 없다.

>>> 하지만 메소드 오버로딩(overloading)을 이용하면, 같은 이름의 메소드를 중복하여 정의할 수 있다.

메소드 오버로딩이란 매개변수의 개수나 타입을 다르게 하여 같은 이름의 또 다른 메소드를 작성하는 것이다.

클래스의 구성요소

자바에서 클래스는 멤버(member)로 속성을 표현하는 필드(field)와 기능을 표현하는 메소드(method)를 가진다.

클래스는 생성된 객체의 필드를 초기화해주는 특별한 메소등인 생성자(constructor)을 가진다.

```jsx
class Phone {
	private String modelName;
	private int modelYear; 
```



**문자열**

**제어문**

**배열**

**메소드**

**클래스**

**추상클래스와 인터페이스**

**제네릭스**

**익명클래스, 람다와 스트림**

**예외처리**

**쓰레드**

**입출력과 파일**
